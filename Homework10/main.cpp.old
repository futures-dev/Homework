///////////////////////////////////////////////////////////////////////////////
/// \file
/// \brief Main entry point
///
/// This file contains a partial implementation for the simulation. It is
/// task for students to finish this implementation.
///
///////////////////////////////////////////////////////////////////////////////

/*Kolos Maria BSE141-1
Project #10 Enhanced Parking Lot*/

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <stack>
#include <stdexcept>
#include <vector>
#include <algorithm>

#include "car.h"


const int PARKING_SPOTS_PER_AISLE = 3;      ///< Determines a number of cars per an aisle
const int NUMBER_OF_AISLES = 5;             ///< Determines a number of aisls in the parking


/** \brief Defines an Aisle in some parking */
typedef std::stack<std::string> ParkAisle;

/** \brief Defines a parking containing some aisles */
typedef std::vector<ParkAisle> Parking;

/** \brief Defines a collection of cars most likely implemented as a vector of cars */
typedef std::vector<Car> Cars;


/** \brief Iterates through the vector of stacks, looking for the first stack that
*  does not contain three cars. If all five aisles (stacks) are full, output a message
*  indicating such; otherwise place the license plate into the first non-full stack.
*/
void handle_arrival(Cars &cars, Parking &parking_lot,
                    const std::string &plate);


/** \brief Locates the departing vehicle from the \a cars vector using function \a find_car() and
*  removes the departing car's license plate from the corresponding aisle.
*/
void handle_departure(Cars &cars, Parking &parking_lot, const std::string &plate);


/** \brief Returns a reference to the \a Car object stored in the vector \a cars
*  whose license plate equals the parameter \a plate.
*/
Car &find_car(Cars &cars, const std::string &plate);

bool Place(Parking &parking_lot, const std::string &plate, int &a);


//------------------------------------------------------------------------------


/** \brief Main entry point of the program
*
*  Should obtain at least 1 command line parameter, which is interpreted as the name of a
*  file with parking day's payload
*/


int main(int argc, char *argv[]) {
    try {
        /*if (argc < 2)
        {
            std::cerr << "Usage:\n" << argv[0] << " data-file";
            return EXIT_FAILURE;
        }*/

        //std::ifstream inf(argv[1]);
        std::ifstream inf("data.txt");

        //output file
        std::ofstream out;
        out.open("output.txt");

        if (!inf) {
            std::cerr << "Could not open " << argv[1];

            return EXIT_FAILURE;
        }

        Cars cars;
        Parking parking_lot(NUMBER_OF_AISLES);

        //initialization
        for (int i = 0; i < NUMBER_OF_AISLES; i++) {
            parking_lot[i] = ParkAisle();
        }

        while (!inf.eof()) {

            std::string action, plate;
            inf >> plate >> action;

            if (action == "arrives") {
                try {
                    handle_arrival(cars, parking_lot, plate);
                }
                catch (std::out_of_range &e) {
                    std::cout << e.what() << "\n";
                }
            }
            else if (action == "departs") {
                handle_departure(cars, parking_lot, plate);

                //output
                std::cout << plate << " moved " << find_car(cars, plate).getTimesMoved() << " times\n";
                out << plate << " moved " << find_car(cars, plate).getTimesMoved() << " times\n";

            }
            else {
                std::cerr << "Unknown action: " << action << std::endl;
            }

        }
        inf.close();

        //output
        std::cout << "\nHere are all the cars that visited the lot today:\n";
        out << "\nHere are all the cars that visited the lot today:\n";

        //sorting into alphabetical order
        std::sort(cars.begin(), cars.end(), [](const Car &a, const Car &b) { return a.getPlate() < b.getPlate(); });
        int c_size = cars.size();
        for (int i = 0; i < c_size; i++) {
            std::cout << cars[i].getPlate() << " moved " << cars[i].getTimesMoved() << " times\n";
            out << cars[i].getPlate() << " moved " << cars[i].getTimesMoved() << " times\n";
        }


        system("pause");

        return EXIT_SUCCESS;
    }
    catch (std::exception &e) {
        std::cerr << e.what() << std::endl;
    }
    catch (...) {
        std::cerr << "Unknown exception caught!" << std::endl;
    }

    return EXIT_FAILURE;
}

//------------------------------------------------------------------------------

/**
*  This is essentially "parking" the car. For this
*  arriving car, also add an entry of type \a Car to the vector \a cars. In this \a Car instance,
*  make sure to record properly the index of the aisle where this car is parked.
*/
void handle_arrival(Cars &cars, Parking &parking_lot,
                    const std::string &plate) {

    int a = -1;//aisle

    //a helping bool function that returns false
    if (!Place(parking_lot, plate, a))
        throw std::out_of_range("Parking is full");
    cars.push_back(Car(plate, a));

}

bool Place(Parking &parking_lot, const std::string &plate, int &a) {
    for (int i = 0; i < NUMBER_OF_AISLES; i++) {
        if (parking_lot[i].size() < 3) {
            parking_lot[i].push(plate);
            a = i;
            return true;
        }
    }
    return false;
}
//------------------------------------------------------------------------------


/**
*  Another stack must be used to move, temporarily, any cars that may be in front of the
*  departing car. Record the number of times a car is moved when accommodating the
*  departure of another car. For the departing car, display the number of times it was moved
*  while it was parked in the lot.
*/
void handle_departure(Cars &cars, Parking &parking_lot, const std::string &plate) {
    bool find = false;
    Car &_car = find_car(cars, plate);


    ParkAisle temp = ParkAisle();
    int a = _car.getAisle();
    while (!parking_lot[a].empty() && parking_lot[a].top() != plate) {
        Car *car = &find_car(cars,
                             parking_lot[a].top());
        if (car != 0) {
            car->setTimesMoved(car->getTimesMoved() + 1);
            temp.push(parking_lot[a].top());
            parking_lot[a].pop();
        }
    }
    if (!parking_lot[a].empty())
        parking_lot[a].pop();
    while (!temp.empty()) {
        parking_lot[a].push(temp.top());
        temp.pop();
    }


}


//------------------------------------------------------------------------------


/**
*  Use the STL \a find() function to perform this task. To use the function correctly, you
*  must supply it with three arguments. The first two arguments specify a range to search.
*  The third argument is the value that the function attempts to find. This argument must be
*  of type \a Car.
*
*  * http://www.cplusplus.com/reference/algorithm/find/
*/
Car &find_car(Cars &cars, const std::string &plate) {
    Car tmp(plate);
    Car &res = *std::find(cars.begin(), cars.end(), tmp);
    return res;

}
